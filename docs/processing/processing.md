<h2 align="Center">Interface application programing</h2>

### Basic 
Processing is a free graphical library and integrated development environment (IDE) built for the electronic arts, new media art, and visual design communities with the purpose of teaching non-programmers the fundamentals of computer programming in a visual context.

Processing uses the Java language, with additional simplifications such as additional classes and aliased mathematical functions and operations. It also provides a graphical user interface for simplifying the compilation and execution stage.

The Processing language and IDE have been the precursor to other projects including Arduino and Wiring.

<h2>Install Software</h2>
To install the software click <a href="https://www.processing.org/download">Processing</a>

- User interface 
<br>
<br>
<img src="img/processing/userui_processing.png">

The Processing IDE (Integrated Development Environment) provides a platform for writing, compiling, and running code, particularly focusing on creative coding and visual arts. The UI in Processing on a MacBook Air or any macOS device generally follows standard design principles for Mac applications.

Here's an overview of what the Processing UI typically looks like on a MacOS (we work on MacOS,For other operating system the working and output are same) :

- Menu Bar: At the top of the screen, you'll find the standard macOS menu bar. It contains options like File, Edit, Sketch, Tools, and Help. These menus offer various functionalities such as creating new sketches, saving, running the code, and accessing preferences.

- Toolbar: The Processing IDE includes a toolbar with icons representing common actions like running the code, stopping execution, saving, and opening sketches.

- Code Editor: The main area of the interface is dedicated to writing and editing code. It features syntax highlighting, line numbers, and other typical code editor functionalities.

- Console/Output Area: Usually placed at the bottom of the window, this area displays feedback, errors, and output generated by the code when it's executed.

- Sketch Area/Canvas: This is where visual output or graphics created by the code are displayed. It could include animations, visual effects, or interactive elements depending on the code written.

- Tabs and Panels: Processing allows for multiple tabs for different sketches or files open simultaneously. Additionally, panels might contain features like libraries, errors, or sketches overview.

Preferences and Settings: Accessible through the menu bar, this section allows users to customize various aspects of the IDE, such as editor settings, font preferences, and more.

Since the Processing IDE follows macOS design conventions, it integrates well with the overall look and feel of the operating system, ensuring familiarity for users accustomed to macOS applications.

Keep in mind that the specifics might slightly vary based on the version of Processing or any customizations you might have made.

If you're using a MacOS and Processing, exploring the interface and experimenting with code within the IDE should be straightforward and consistent with the general macOS UI experience.

<h2>Features</h2> 
Processing includes a sketchbook, a minimal alternative to an integrated development environment (IDE) for organizing projects.

Every Processing sketch is actually a subclass of the PApplet Java class (formerly a subclass of Java's built-in Applet) which implements most of the Processing language's features.[8]

When programming in Processing, all additional classes defined will be treated as inner classes when the code is translated into pure Java before compiling.[9] This means that the use of static variables and methods in classes is prohibited unless Processing is explicitly told to code in pure Java mode.

Processing also allows for users to create their own classes within the PApplet sketch. This allows for complex data types that can include any number of arguments and avoids the limitations of solely using standard data types such as: int (integer), char (character), float (real number), and color (RGB, RGBA, hex).

<h2>Properties</h2>

- Variables (int, float, String): Declares variables to store integers (x), floating-point numbers (y), and strings (message).

- Setup Function (setup()): Initializes the canvas with a size of 400x400 pixels.

- Draw Function (draw()): Runs continuously in a loop and displays shapes and text on the canvas.

- Drawing Shapes (rect(), ellipse()): Draws shapes like rectangles and ellipses on the canvas at specified positions.

- Text Display (text(), textSize()): Displays the string message on the canvas at a specific position with a specified text size.

- Mouse Interaction (mousePressed()): Updates the position of shapes (x and y) based on the mouse coordinates when the mouse is pressed.

This example code covers basic variable declaration, drawing shapes, displaying text, setting up the canvas, and responding to mouse events in Processing.


~~~
          /int x = 100; // Declaration of a variable 'x' of type integer and assignment of value 100
          float y = 200.5; // Declaration of a variable 'y' of type float and assignment of value 200.5
          String message = "Hello, Processing!"; // Declaration of a variable 'message' of type String

          void setup() {
            size(400, 400); // Creates a canvas of size 400x400 pixels
          }

          void draw() {
            background(220); // Sets the background color to light gray

            // Drawing shapes
            fill(255, 0, 0); // Set fill color to red (RGB)
            rect(x, 50, 50, 50); // Draws a red rectangle at position 'x', 50 with width and 
             height of 50

            fill(0, 255, 0); // Set fill color to green (RGB)
            ellipse(200, y, 80, 80); // Draws a green ellipse at position 200, 'y' with a 
             width and height of 80

            // Displaying text
            fill(0); // Set text color to black
            textSize(20); // Set text size to 20
            text(message, 50, 300); // Display the message at position 50, 300
          }

          void mousePressed() {
            x = mouseX; // Update the 'x' position to the current mouse x-coordinate when 
             mouse is pressed
            y = mouseY; // Update the 'y' position to the current mouse y-coordinate when 
             mouse is pressed
          }

~~~

> Output 
Video 
<br>
<br>
<video align="centre" width="100%" height="100%" controls muted>
  <source src="img/processing/processingproparties.mp4" type="video/mp4">
</video>

 <br>
 <br>

 More <a href="https://www.processing.org/examples">Examples</a>
<br>

<h2>New tools similar with Processing</h2>
There are several tools and platforms similar to Processing that cater to creative coding, visual arts, and interactive media. Here are a few notable ones:

- <a href="https://p5js.org/">p5.js</a>: This is a JavaScript library inspired by Processing. It makes it easy to manipulate HTML5 canvas elements and create interactive graphics and animations. p5.js follows similar syntax and principles to Processing, making it accessible for those familiar with Processing.

- <a href="https://openframeworks.cc/">OpenFrameworks</a>: OpenFrameworks is a C++ toolkit for creative coding. It provides a wide range of functions and libraries for creating visual applications, installations, and interactive projects. It's highly versatile and is often used in interactive art installations and multimedia projects.

- <a href="https://libcinder.org/">Cinder</a>: Similar to OpenFrameworks, Cinder is a C++ creative coding framework that enables rapid prototyping of multimedia applications. It's known for its performance and is used in various interactive installations, simulations, and multimedia projects.

- <a href="https://visualprogramming.net/">vvvv</a>: This graphical programming environment focuses on multimedia and interactive installations. It uses a visual programming language to create real-time content and interactive media.

Each of these tools has its strengths and is suited to different purposes within the realm of creative coding, visual arts, and interactive media. They vary in terms of programming languages, ease of use, performance, and the specific types of projects they are best suited for. Exploring a few of these might help you find one that aligns best with your creative goals and coding preferences!

### Interactive Circle Clicker

<h3>Introduction :</h3>
Create an interactive sketch in Processing where users click on a moving circle within a canvas.
<h3>Implementation :</h3>

- Canvas Size: 400x400 pixels
- Circle Behavior:
  - Random movement of a red circle within the canvas.
  - Mouse interaction triggers a change in the circle's state when the mouse is within close proximity.

<h3>User Interaction :</h3>

- Users are prompted to click on the moving circle.
- Upon successful click, a congratulatory message is displayed on the canvas.

<h3>Conclusion :</h3>
The project demonstrates a basic interactive sketch using Processing. Users engage by clicking on a moving circle within the canvas, prompting a congratulatory message upon successful interaction.

> Code

    ~~~
          float circleX, circleY;
    boolean clickedCircle = false;

    void setup() {
      size(400, 400);
      circleX = random(width);
      circleY = random(height); 
    }

    void draw() {
      background(220);
      
      if (!clickedCircle) {
        fill(255, 0, 0);
        ellipse(circleX, circleY, 50, 50); 

        if (mousePressed && dist(mouseX, mouseY, circleX, circleY) < 25) {
          clickedCircle = true;
        }
      } else {
        textAlign(CENTER, CENTER);
        textSize(20);
        fill(0);
        text("Congratulations!\nYou clicked the circle!", width / 2, height / 2);
      }
    }
    ~~~

> Video
<video align="centre" width="100%" height="100%" controls muted>
  <source src="img/processing/circle_game.mp4" type="video/mp4">
</video>


### Processing with Arduino

<h2 align="center">Automated Distance Sensing and Alert System using Arduino</h2>

<h3>Introduction : </h3>
The system utilizes an ultrasonic sensor to measure distances and a servo motor to scan the surroundings within a defined range. It operates on an Arduino platform, facilitating real-time distance measurements and subsequent response mechanisms. The primary objective is to detect objects within a certain distance and trigger visual and auditory alerts accordingly.

<h3>Components needed</h3> :

- Arduino UNO<br>
- SG90 Micro-servo motor<br>
- Ultrasonic Sensor - HC-SR04 <br>
- LED
- Breadboard <br>
- Jumper wires <br>

<h3>Software : </h3> <br>
<a href="https://www.arduino.cc/en/software">Arduino IDE</a> and <a href="https://processing.org/download/">Processing</a>
<br>

<h3>Steps :</h3> 

Circuit Setup:

- Ultrasonic Sensor:
  - VCC pin of the sensor -> 5V pin on Arduino
  - Trig pin -> Digital pin 10 on Arduino
  - Echo pin -> Digital pin 11 on Arduino
  - GND pin of the sensor -> GND pin on Arduino

- Servo Motor:
  - Signal wire  -> Digital pin 12 on Arduino
  - VCC -> 5V pin on Arduino
  - GND -> GND pin on Arduino

- LED:
  - Anode (longer leg) -> Resistor -> Digital pin 13 on Arduino
  - Cathode (shorter leg) -> GND pin on Arduino

- Buzzer:
  - Positive (usually marked with a “+” or longer leg) -> Digital pin 9 on Arduino
  - Negative -> GND pin on Arduino

- Power:
  - Arduino board powered through USB or an external power supply.
 <br>

 <img src="img/processing/processingwitharduino.png">

> Arduino Programming: (code and explanation (comments))

 - Code the Arduino to read data from the ultrasonic sensor.<br>
 - Control the servo motor to enable it to sweep across a defined angle range, like a radar scanner.<br>
 - Process the data received from the sensor.<br>

    ~~~
          #include <Servo.h>

      // Define the pins
      const int trigPin = 10;       // Trigger pin for ultrasonic sensor
      const int echoPin = 11;       // Echo pin for ultrasonic sensor
      const int ledPin = 13;        // LED pin
      const int buzzerPin = 9;      // Buzzer pin

      long duration;                 // To store the duration of sound wave travel
      int distance;                  // Calculated distance variable
      Servo myServo;                 // Servo motor object

      void setup() {
        // Set pin modes
        pinMode(trigPin, OUTPUT);   // Trigger pin as output
        pinMode(echoPin, INPUT);    // Echo pin as input
        pinMode(ledPin, OUTPUT);    // LED pin as output
        pinMode(buzzerPin, OUTPUT); // Buzzer pin as output
        
        Serial.begin(9600);         // Start serial communication for debugging
        myServo.attach(12);         // Attach the servo to pin 12
      }

      void loop() {
        // Sweep the servo motor from 15 to 165 degrees
        for (int i = 15; i <= 165; i++) {
          myServo.write(i);         // Set servo to angle i
          delay(30);                // Delay for servo movement
          distance = calculateDistance(); // Calculate distance
          Serial.print(i);          // Print servo angle
          Serial.print(",");        // Separator
          Serial.print(distance);   // Print distance measured
          Serial.print(".");        // Separator

          // Check if an object is detected within 40 cm
          if (distance < 40) {
            digitalWrite(ledPin, HIGH); // Turn on LED
            tone(buzzerPin, 1000);      // Play a tone on the buzzer
          } else {
            digitalWrite(ledPin, LOW);  // Turn off LED
            noTone(buzzerPin);          // Turn off buzzer
          }
        }

        // Sweep the servo motor from 165 to 15 degrees
        for (int i = 165; i > 15; i--) {
          myServo.write(i);         // Set servo to angle i
          delay(30);                // Delay for servo movement
          distance = calculateDistance(); // Calculate distance
          Serial.print(i);          // Print servo angle
          Serial.print(",");        // Separator
          Serial.print(distance);   // Print distance measured
          Serial.print(".");        // Separator
        }
      }

      // Function to calculate distance using the ultrasonic sensor
      int calculateDistance() {
        digitalWrite(trigPin, LOW);       // Set trigger pin low
        delayMicroseconds(2);             
        
        digitalWrite(trigPin, HIGH);      // Send a 10us pulse to trigger the sensor
        delayMicroseconds(10);
        digitalWrite(trigPin, LOW);
        
        duration = pulseIn(echoPin, HIGH);  // Measure the duration of the echo pulse
        distance = duration * 0.034 / 2;    // Calculate distance using speed of sound
        return distance;                    // Return the calculated distance
      }


    ~~~ 

>Processing Programming: (Code and explanation (comments))

 - Create a visualization in Processing to represent the radar screen.<br>
 - Establish communication between Arduino and Processing (serial communication) to receive data.<br>
 - Use the received data to display objects or obstacles on the screen.<br>

    ~~~
            // Importing necessary libraries
        import processing.serial.*;  // Library for serial communication
        import java.awt.event.KeyEvent; // Library for keyboard events
        import java.io.IOException; // Library for handling input/output exceptions

        // Declaring variables
        Serial myPort; // Serial object for communication
        String angle = ""; // String to store angle data
        String distance = ""; // String to store distance data
        String data = ""; // String to store incoming data
        String noObject; // String indicating if an object is within range
        float pixsDistance; // Calculated distance for visualization
        int iAngle, iDistance; // Integers for angle and distance
        int index1 = 0; // Index variable for string manipulation
        int index2 = 0; // Another index variable for string manipulation
        PFont orcFont; // Font object for text display

        void setup() {
          size(1200, 700); // Canvas size
          smooth(); // Smoothing for better graphics
          myPort = new Serial(this, "COM4", 9600); // Initialize serial communication on a specific port at a certain baud rate
          myPort.bufferUntil('.'); // Set a buffer until a period '.' is received
        }

        void draw() {
          // Background and styling
          fill(98, 245, 31);
          noStroke();
          fill(0, 4);
          rect(0, 0, width, height - height * 0.065);

          // Radar visualization
          fill(98, 245, 31);
          drawRadar();
          drawLine();
          drawObject();
          drawText();
        }

        void serialEvent(Serial myPort) {
          // Read data from serial port until '.' is encountered
          data = myPort.readStringUntil('.');
          data = data.substring(0, data.length() - 1); // Remove the last character (which is '.')

          // Extract angle and distance from received data
          index1 = data.indexOf(",");
          angle = data.substring(0, index1);
          distance = data.substring(index1 + 1, data.length());

          // Convert string data to integers for further use
          iAngle = int(angle);
          iDistance = int(distance);
        }

        void drawRadar() {
          pushMatrix();
          translate(width / 2, height - height * 0.074); // Move origin to the bottom center of the screen
          noFill();
          strokeWeight(2);
          stroke(98, 245, 31);

          // Draw arcs representing different ranges
          arc(0, 0, (width - width * 0.0625), (width - width * 0.0625), PI, TWO_PI);
          arc(0, 0, (width - width * 0.27), (width - width * 0.27), PI, TWO_PI);
          arc(0, 0, (width - width * 0.479), (width - width * 0.479), PI, TWO_PI);
          arc(0, 0, (width - width * 0.687), (width - width * 0.687), PI, TWO_PI);

          // Draw lines indicating specific angles
          line(-width / 2, 0, width / 2, 0);
          // ... Lines for specific angles (30, 60, 90, 120, 150 degrees)
          popMatrix();
        }

        void drawObject() {
          pushMatrix();
          translate(width / 2, height - height * 0.074);
          strokeWeight(9);
          stroke(255, 10, 10); // Red color for object visualization
          pixsDistance = iDistance * ((height - height * 0.1666) * 0.025); // Calculate pixel distance 
           based on received distance

          // Draw the object line if within a certain range
          if (iDistance < 40) {
            line(pixsDistance * cos(radians(iAngle)), -pixsDistance * sin(radians(iAngle)), (width - width 
             * 0.505) * cos(radians(iAngle)), -(width - width * 0.505) * sin(radians(iAngle)));
          }
          popMatrix();
        }

        void drawLine() {
          pushMatrix();
          strokeWeight(9);
          stroke(30, 250, 60); // Green color for line indicating distance
          translate(width / 2, height - height * 0.074);

          // Draw line indicating the detected object's distance and angle
          line(0, 0, (height - height * 0.12) * cos(radians(iAngle)), -(height - height * 0.12) * 
           sin(radians(iAngle)));
          popMatrix();
        }

        void drawText() {
          // Display information text
          pushMatrix();
          if (iDistance > 40) {
            noObject = "Out of Range";
          } else {
            noObject = "In Range";
          }
          
          // Styling and positioning for text
          fill(0, 0, 0);
          noStroke();
          rect(0, height - height * 0.0648, width, height);
          fill(98, 245, 31);
          textSize(25);
          // ... Text displaying range markers, angle, distance, labels for specific angles, etc.
          popMatrix();
        }

    ~~~

Integration:

 - Upload the Arduino code onto the board.<br>
 - Run the Processing sketch on the computer.<br>


- Functionality :
  - The Arduino continuously sweeps the servo motor while measuring distances using the ultrasonic sensor.

  - Calculates the distance at different angles and sends this information serially to the connected computer.
  - Provides feedback through LED and buzzer based on detected object proximity within the specified range.

 <img src="img/processing/processingwitharduino.jpeg">
 <br>

Project video :

<video align="centre" width="100%" height="100%" controls muted>
  <source src="img/processing/processingwitharduino.mp4" type="video/mp4">
</video>
<br>

### Kinect,Leapmotion or IOT platform

Communicating with Kinect, Leap Motion, or IoT platforms in Processing involves using specific libraries and APIs tailored for each device or platform. Here's a brief overview of how you might interface with each:

- Kinect with Processing:

  - Example: Using SimpleOpenNI or OpenKinect libraries in Processing to access Kinect's depth sensing and skeletal tracking features.
Application: Creating interactive installations, gesture-controlled applications, virtual reality experiences, or games that utilize body movements.
- Leap Motion with Processing:

  - Example: Implementing the Leap Motion for Processing library to capture hand and finger tracking data.
  - Application: Developing interactive interfaces, 3D modeling applications, educational tools, or games that respond to hand gestures and movements.
- IoT Platforms with Processing:

  - Example: Using HTTP requests or specific IoT platform libraries/APIs to send and receive data from connected devices in Processing.
  - Application: Building data visualization dashboards, smart home applications, environmental monitoring systems, or interactive installations that utilize data from IoT sensors.
<h2>Example Applications:</h2>
<br>
- Gesture-Controlled Art Installation: Combining Kinect and Processing to create an interactive art piece where people's movements manipulate visual elements on a screen or projection.

- Educational Tool with Leap Motion: Developing a physics simulation using Leap Motion and Processing, allowing users to interact with virtual objects and observe their behavior based on hand gestures.

- IoT-Enabled Smart Home Interface: Using Processing and IoT platform APIs to design a user interface that controls various smart devices in a home, such as lights, thermostats, and security systems.

- Environmental Monitoring System: Integrating IoT sensors with Processing to collect and visualize data related to temperature, humidity, or air quality, creating a real-time monitoring system.

Each of these examples showcases how these technologies can be combined with Processing to create diverse and interactive applications across art, education, home automation, and data visualization.

### GUI

Creating a Graphic User Interface (GUI) in Processing involves a combination of design principles and programming techniques. Here's a detailed breakdown of interpreting and implementing design and programming protocols for building a GUI in Processing:

<h2>Interpret Design Protocols</h2>

- User Requirements and Flow:

  - Understand the user's needs and how they'll interact with the interface.
  - Define the user flow, outlining how users will navigate through the interface.
- Wireframing and Sketching:

  - Create wireframes or sketches that depict the layout and arrangement of elements in the interface.
  - Plan the position of buttons, input fields, text areas, and any other interactive elements.
- Visual Design and Components:

  - Choose appropriate colors, typography, and visual components that align with the interface's purpose and the user's expectations.
  - Design icons, buttons, backgrounds, and other visual elements that maintain consistency and clarity.
- Accessibility and Usability:

  - Ensure the interface is accessible and usable for all users, adhering to accessibility guidelines.
  - Focus on intuitive navigation, clear feedback, and readability of content.
<h2>Implement Programming Protocols</h2>

- Choosing Libraries:

  - Select a suitable GUI library for Processing, such as ControlP5 or G4P, based on the desired interface elements and functionalities.
- Initializing the Library:

  - Import and initialize the chosen GUI library within the Processing sketch.
  - Create necessary objects to manage GUI elements.
- Designing UI Elements:

  - Use library functions to create buttons, sliders, text inputs, checkboxes, etc., based on the wireframes or sketches.
  - Define the appearance, position, and behavior of each UI element within the Processing sketch.
- Event Handling and Functionality:

  - Implement event handlers or callback functions to respond to user interactions with GUI elements (e.g., button clicks, slider changes).
  - Write functions or methods that execute specific actions based on user input.
- Layout and Structure:

  - Organize and structure the GUI elements within the sketch, ensuring proper alignment and spacing for a visually appealing layout.
- Testing and Refinement:

  - Test the GUI extensively to identify and resolve any bugs or usability issues.
  - Gather feedback from users and iterate on the design and functionality for improvements

<h2>Considerations</h2>

- Responsive Design: Ensure the interface adapts well to different screen sizes and orientations.
- Scalability: Design the GUI in a way that allows for easy expansion and addition of new features.
- Documentation and Maintenance: Document your code and keep it well-structured for easier maintenance and future updates.

By following these protocols, you can create a functional and visually appealing GUI in Processing that meets the needs of the users and enhances the overall user experience.  




