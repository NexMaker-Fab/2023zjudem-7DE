<h2 align="Center">Interface application programing</h2>

### Basic 
Processing is a free graphical library and integrated development environment (IDE) built for the electronic arts, new media art, and visual design communities with the purpose of teaching non-programmers the fundamentals of computer programming in a visual context.

Processing uses the Java language, with additional simplifications such as additional classes and aliased mathematical functions and operations. It also provides a graphical user interface for simplifying the compilation and execution stage.

The Processing language and IDE have been the precursor to other projects including Arduino and Wiring.

<h2>Install Software</h2>
To install the software click <a href="https://www.processing.org/download">Processing</a>

- User interface 
<br>
<br>
<img src="img/processing/userui_processing.png">

The Processing IDE (Integrated Development Environment) provides a platform for writing, compiling, and running code, particularly focusing on creative coding and visual arts. The UI in Processing on a MacBook Air or any macOS device generally follows standard design principles for Mac applications.

Here's an overview of what the Processing UI typically looks like on a MacOS (we work on MacOS,For other operating system the working and output are same) :

- Menu Bar: At the top of the screen, you'll find the standard macOS menu bar. It contains options like File, Edit, Sketch, Tools, and Help. These menus offer various functionalities such as creating new sketches, saving, running the code, and accessing preferences.

- Toolbar: The Processing IDE includes a toolbar with icons representing common actions like running the code, stopping execution, saving, and opening sketches.

- Code Editor: The main area of the interface is dedicated to writing and editing code. It features syntax highlighting, line numbers, and other typical code editor functionalities.

- Console/Output Area: Usually placed at the bottom of the window, this area displays feedback, errors, and output generated by the code when it's executed.

- Sketch Area/Canvas: This is where visual output or graphics created by the code are displayed. It could include animations, visual effects, or interactive elements depending on the code written.

- Tabs and Panels: Processing allows for multiple tabs for different sketches or files open simultaneously. Additionally, panels might contain features like libraries, errors, or sketches overview.

Preferences and Settings: Accessible through the menu bar, this section allows users to customize various aspects of the IDE, such as editor settings, font preferences, and more.

Since the Processing IDE follows macOS design conventions, it integrates well with the overall look and feel of the operating system, ensuring familiarity for users accustomed to macOS applications.

Keep in mind that the specifics might slightly vary based on the version of Processing or any customizations you might have made.

If you're using a MacOS and Processing, exploring the interface and experimenting with code within the IDE should be straightforward and consistent with the general macOS UI experience.

<h2>Features</h2> 
Processing includes a sketchbook, a minimal alternative to an integrated development environment (IDE) for organizing projects.

Every Processing sketch is actually a subclass of the PApplet Java class (formerly a subclass of Java's built-in Applet) which implements most of the Processing language's features.[8]

When programming in Processing, all additional classes defined will be treated as inner classes when the code is translated into pure Java before compiling.[9] This means that the use of static variables and methods in classes is prohibited unless Processing is explicitly told to code in pure Java mode.

Processing also allows for users to create their own classes within the PApplet sketch. This allows for complex data types that can include any number of arguments and avoids the limitations of solely using standard data types such as: int (integer), char (character), float (real number), and color (RGB, RGBA, hex).

<h2>Example</h2>
The following code is a better example of the look and feel of the language.

~~~
// Hello mouse.
void setup() {
  size(400, 400);
  stroke(255);
  background(192, 64, 0);
}

void draw() {
  line(150, 25, mouseX, mouseY);
}
~~~

> Output 
<br>
<br>
 <img src="img/processing/processing example_1.png">
 <br>
 <br>

> Video 
<br>
<br>
<video align="centre" width="100%" height="100%" controls muted>
  <source src="img/processing/processingexample_video_1.mp4" type="video/mp4">
</video>

 <br>
 <br>

 More <a href="https://www.processing.org/examples">Examples</a>
<br>

<h2>New tools similar with Processing</h2>
There are several tools and platforms similar to Processing that cater to creative coding, visual arts, and interactive media. Here are a few notable ones:

- <a href="https://p5js.org/">p5.js</a>: This is a JavaScript library inspired by Processing. It makes it easy to manipulate HTML5 canvas elements and create interactive graphics and animations. p5.js follows similar syntax and principles to Processing, making it accessible for those familiar with Processing.

- <a href="https://openframeworks.cc/">OpenFrameworks</a>: OpenFrameworks is a C++ toolkit for creative coding. It provides a wide range of functions and libraries for creating visual applications, installations, and interactive projects. It's highly versatile and is often used in interactive art installations and multimedia projects.

- <a href="https://libcinder.org/">Cinder</a>: Similar to OpenFrameworks, Cinder is a C++ creative coding framework that enables rapid prototyping of multimedia applications. It's known for its performance and is used in various interactive installations, simulations, and multimedia projects.

- <a href="https://visualprogramming.net/">vvvv</a>: This graphical programming environment focuses on multimedia and interactive installations. It uses a visual programming language to create real-time content and interactive media.

Each of these tools has its strengths and is suited to different purposes within the realm of creative coding, visual arts, and interactive media. They vary in terms of programming languages, ease of use, performance, and the specific types of projects they are best suited for. Exploring a few of these might help you find one that aligns best with your creative goals and coding preferences!

### Interactive game with mouse

- Game Elements:
Ball (ellipse()): Represented as a small circle (ellipse) moving around the screen.
Movable Bar (rect()): A vertical bar that follows the y-axis movement of the mouse.

Gameplay:
- Ball Movement: 
*The ball starts from the center of the screen and moves at a random speed in both the x and y directions.<br>
*It continuously updates its position (x and y variables) based on its speed (speedX and speedY variables).<br>
*The ball bounces off the walls of the window and changes direction when it hits them.<br>

- Movable Bar Interaction:

*There is a vertical bar on the right side of the screen that follows the vertical movement of the mouse (mouseY).
*When the ball collides with this vertical bar, it changes its horizontal direction (speedX) to simulate a bounce off the bar.

- Game Rules:

*If the ball hits the movable bar, its horizontal direction (speedX) gets inverted.<br>
*If the ball hits the left or right walls, its horizontal direction gets inverted and its speed increases by 10% (speedX gets multiplied by -1.1 and speedY gets multiplied by 1.1).<br>
*If the ball hits the top or bottom walls, its vertical direction (speedY) gets inverted.<br>

- Reset:

*Clicking the mouse resets the ball to the center of the screen and assigns it a new random speed and direction.<br>

- Objective:
The objective appears to be to keep the ball bouncing within the screen boundaries and try to control its movement by adjusting the position of the movable bar to prevent it from going out of bounds or missing the bar.<br>
It's a simple game of controlling the bar's position to keep the ball in play for as long as possible!

> Processing Code 
~~~
// Declare global variables for ball and bar positions and speeds
float x, y, speedX, speedY;
float diam = 10; // Diameter of the ball
float rectSize = 200; // Size of the movable bar

void setup() {
  fullScreen(); // Sets the sketch to fullscreen
  fill(0, 255, 0); // Fill color for the ball
  reset(); // Calls the reset function to initialize positions and speeds
}

void reset() {
  // Reset the ball position to the center of the screen
  x = width/2;
  y = height/2;
  
  // Assign random speeds in both x and y directions for the ball
  speedX = random(3, 5);
  speedY = random(3, 5);
}

void draw() { 
  background(0); // Sets the background color to black
  
  // Draw the ball at its current position
  ellipse(x, y, diam, diam);

  // Draw the movable bar on the right side of the screen
  rect(0, 0, 20, height); // Left wall
  rect(width-30, mouseY-rectSize/2, 10, rectSize); // Movable bar
  
  // Update ball position by adding its speed to its current position
  x += speedX;
  y += speedY;

  // if ball hits the movable bar, invert X direction
  if (x > width-30 && x < width -20 && y > mouseY-rectSize/2 && y < mouseY+rectSize/2) {
    speedX = speedX * -1; // Change horizontal direction
  } 

  // if ball hits left or right walls, change direction of X and increase speed
  if (x < 25 || x > width - 25) {
    speedX *= -1.1; // Invert X direction and increase speed
    speedY *= 1.1; // Increase Y speed
    x += speedX; // Move the ball
  }

  // if ball hits top or bottom walls, change direction of Y   
  if (y > height || y < 0) {
    speedY *= -1; // Invert Y direction
  }
}

void mousePressed() {
  reset(); // Reset the ball's position and speed when mouse is clicked
}

~~~
> Output (screen recorded video)
<video align="centre" width="100%" height="100%" controls muted>
  <source src="img/processing/processingsimplegame_1.mp4" type="video/mp4">
</video>

### Processing with Arduino

<h2 align="center">An Arduino Radar System with Real-time Processing<h2>

<h3>Introduction : </h3>
Processing for real-time analysis and visualization, this project merges hardware and software. Arduino manages sensor data and motor control, while Processing interprets this data, creating a dynamic visual interface. Experience the synergy between Arduino's hardware control and Processing's data visualization in crafting an interactive radar system.

<h3>Components needed</h3> :
*Arduino UNO<br>
*SG90 Micro-servo motor<br>
*Ultrasonic Sensor - HC-SR04 (Generic)<br>
*Breadboard (generic)<br>
*Jumper wires (generic)<br>
<br>
<img src="img/processing/component_for_radar.png">
<br>

<h3>Software </h3>: <br>
<a href="https://www.arduino.cc/en/software">Arduino IDE</a> and <a href="https://processing.org/download/">Processing</a>
<br>

<h3>Steps</h3> :

Circuit Setup:

 - Connect the ultrasonic sensor to the Arduino board.<br>
 - Connect the servo motor to the Arduino to enable rotation.<br>
 - Power up the components and ensure they're properly connected.<br>
 <br>

 <img src="img/processing/radar_diagram.png">

Arduino Programming: (code and explanation (comments))

 - Code the Arduino to read data from the ultrasonic sensor.<br>
 - Control the servo motor to enable it to sweep across a defined angle range, like a radar scanner.<br>
 - Process the data received from the sensor.<br>

    ~~~
    #include <Servo.h> // Include the Servo library

      const int trigPin = 10; // Pin connected to the trigger pin of the ultrasonic sensor
      const int echoPin = 11; // Pin connected to the echo pin of the ultrasonic sensor
      long duration; // Variable to hold the duration of sound wave travel
      int distance; // Variable to hold the calculated distance
      Servo myServo; // Create a servo object

      void setup() {
        pinMode(trigPin, OUTPUT); // Set trigPin as an output
        pinMode(echoPin, INPUT); // Set echoPin as an input
        Serial.begin(9600); // Initialize serial communication
        myServo.attach(12); // Attach the servo to pin 12
      }

      void loop() {
        // Sweep the servo from 15 to 165 degrees
        for (int i = 15; i <= 165; i++) {
          myServo.write(i); // Move the servo to position 'i'
          delay(30); // Delay for servo movement
          distance = calculateDistance(); // Calculate distance
          Serial.print(i); // Print servo position
          Serial.print(",");
          Serial.print(distance); // Print measured distance
          Serial.print(".");
        }

        // Sweep the servo from 165 to 15 degrees
        for (int i = 165; i > 15; i--) {
          myServo.write(i); // Move the servo to position 'i'
          delay(30); // Delay for servo movement
          distance = calculateDistance(); // Calculate distance
          Serial.print(i); // Print servo position
          Serial.print(",");
          Serial.print(distance); // Print measured distance
          Serial.print(".");
        }
      }

      int calculateDistance() {
        digitalWrite(trigPin, LOW); // Set the trigPin low
        delayMicroseconds(2); // Delay to ensure stability

        digitalWrite(trigPin, HIGH); // Send a 10 microsecond high pulse to trigger
        delayMicroseconds(10);
        digitalWrite(trigPin, LOW); // Set the trigger pin low after the pulse

        duration = pulseIn(echoPin, HIGH); // Measure the duration of the echo pulse
        distance = duration * 0.034 / 2; // Calculate distance based on the speed of sound
        return distance; // Return the calculated distance
      }

    ~~~ 

Processing Programming: (Code and explanation (comments))

 - Create a visualization in Processing to represent the radar screen.<br>
 - Establish communication between Arduino and Processing (serial communication) to receive data.<br>
 - Use the received data to display objects or obstacles on the screen.<br>

    ~~~
            // Importing necessary libraries
        import processing.serial.*;  // Library for serial communication
        import java.awt.event.KeyEvent; // Library for keyboard events
        import java.io.IOException; // Library for handling input/output exceptions

        // Declaring variables
        Serial myPort; // Serial object for communication
        String angle = ""; // String to store angle data
        String distance = ""; // String to store distance data
        String data = ""; // String to store incoming data
        String noObject; // String indicating if an object is within range
        float pixsDistance; // Calculated distance for visualization
        int iAngle, iDistance; // Integers for angle and distance
        int index1 = 0; // Index variable for string manipulation
        int index2 = 0; // Another index variable for string manipulation
        PFont orcFont; // Font object for text display

        void setup() {
          size(1200, 700); // Canvas size
          smooth(); // Smoothing for better graphics
          myPort = new Serial(this, "COM4", 9600); // Initialize serial communication on a specific port at a certain baud rate
          myPort.bufferUntil('.'); // Set a buffer until a period '.' is received
        }

        void draw() {
          // Background and styling
          fill(98, 245, 31);
          noStroke();
          fill(0, 4);
          rect(0, 0, width, height - height * 0.065);

          // Radar visualization
          fill(98, 245, 31);
          drawRadar();
          drawLine();
          drawObject();
          drawText();
        }

        void serialEvent(Serial myPort) {
          // Read data from serial port until '.' is encountered
          data = myPort.readStringUntil('.');
          data = data.substring(0, data.length() - 1); // Remove the last character (which is '.')

          // Extract angle and distance from received data
          index1 = data.indexOf(",");
          angle = data.substring(0, index1);
          distance = data.substring(index1 + 1, data.length());

          // Convert string data to integers for further use
          iAngle = int(angle);
          iDistance = int(distance);
        }

        void drawRadar() {
          pushMatrix();
          translate(width / 2, height - height * 0.074); // Move origin to the bottom center of the screen
          noFill();
          strokeWeight(2);
          stroke(98, 245, 31);

          // Draw arcs representing different ranges
          arc(0, 0, (width - width * 0.0625), (width - width * 0.0625), PI, TWO_PI);
          arc(0, 0, (width - width * 0.27), (width - width * 0.27), PI, TWO_PI);
          arc(0, 0, (width - width * 0.479), (width - width * 0.479), PI, TWO_PI);
          arc(0, 0, (width - width * 0.687), (width - width * 0.687), PI, TWO_PI);

          // Draw lines indicating specific angles
          line(-width / 2, 0, width / 2, 0);
          // ... Lines for specific angles (30, 60, 90, 120, 150 degrees)
          popMatrix();
        }

        void drawObject() {
          pushMatrix();
          translate(width / 2, height - height * 0.074);
          strokeWeight(9);
          stroke(255, 10, 10); // Red color for object visualization
          pixsDistance = iDistance * ((height - height * 0.1666) * 0.025); // Calculate pixel distance 
           based on received distance

          // Draw the object line if within a certain range
          if (iDistance < 40) {
            line(pixsDistance * cos(radians(iAngle)), -pixsDistance * sin(radians(iAngle)), (width - width 
             * 0.505) * cos(radians(iAngle)), -(width - width * 0.505) * sin(radians(iAngle)));
          }
          popMatrix();
        }

        void drawLine() {
          pushMatrix();
          strokeWeight(9);
          stroke(30, 250, 60); // Green color for line indicating distance
          translate(width / 2, height - height * 0.074);

          // Draw line indicating the detected object's distance and angle
          line(0, 0, (height - height * 0.12) * cos(radians(iAngle)), -(height - height * 0.12) * 
           sin(radians(iAngle)));
          popMatrix();
        }

        void drawText() {
          // Display information text
          pushMatrix();
          if (iDistance > 40) {
            noObject = "Out of Range";
          } else {
            noObject = "In Range";
          }
          
          // Styling and positioning for text
          fill(0, 0, 0);
          noStroke();
          rect(0, height - height * 0.0648, width, height);
          fill(98, 245, 31);
          textSize(25);
          // ... Text displaying range markers, angle, distance, labels for specific angles, etc.
          popMatrix();
        }

    ~~~

Integration:

 - Upload the Arduino code onto the board.<br>
 - Run the Processing sketch on the computer.<br>


Functionality:
 - The ultrasonic sensor measures distances by sending and receiving sound waves.<br>
 - The servo motor rotates the sensor, scanning an area.<br>
 - Arduino processes the sensor data and communicates it to the computer.<br>
 - Processing receives this data and creates a real-time visualization of detected objects on the screen.<br>

 <img src="img/processing/processingradar_connection.png">
 <br>

Project video :

<video align="centre" width="100%" height="100%" controls muted>
  <source src="img/processing/processing_radar_video.mp4" type="video/mp4">
</video>
